# 技术选型与架构架构说明 (TECH_STACK.md)

本项目作为一个从 7 年老项目（CRA）迁移而来的自定义 SSR 架构，在技术选型上优先考虑了**稳定性、透明度、启动性能**以及对 **Serverless** 环境的适配。

## 1. 核心服务端框架：Koa vs NestJS

**结论：选择 Koa**

### 为什么不选 NestJS？
*   **启动开销**：NestJS 基于装饰器和依赖注入（DI），启动时有较大的 IoC 容器初始化开销。在 AWS Lambda 环境下，这会显著增加“冷启动”耗时。
*   **黑盒封装**：NestJS 对底层 HTTP 流的控制较厚。SSR 的核心是操作 `Stream` (React 19 `renderToPipeableStream`)，Koa 的剥洋葱模型和透明的 `ctx` 能够提供更精准的流控支持。
*   **迁移成本**：本项目源于老旧系统改造，Koa 的非侵入式特性允许业务逻辑以“平滑挂载”的方式实现 SSR，而 NestJS 的强约定会迫使老代码进行伤筋动骨的模块化重构。

### 为什么选择 Koa？
*   **极致轻量**：仅包含中间件内核，冷启动速度极快。
*   **透明可控**：开发者可以一眼望到底，精准管理 `prefetch` -> `ssr render` -> `html stream` 的每一个环节。

---

## 2. 渲染架构：自定义 SSR vs Next.js

**结论：选择 自定义 Webpack + React 19**

*   **安全性**：Next.js 历史漏洞较多，自定义架构可以规避复杂的框架级安全隐患。
*   **扩展性**：支持 **Module Federation (模块联邦)** 等微前端特性，这在闭源的 Next.js 体系中实现成本很高。
*   **性能回退 (Fallback)**：本项目实现了 `isSSR` 标记识别，在服务端报错或 CDN 异常时能 100% 自动回退到 CSR，确保业务永不宕机。

---

## 3. 基础设施：AWS Serverless 金三角

本项目采用 **S3 + CloudFront + Lambda** 架构：

*   **S3 (OSS)**: 负责存储静态 JS/CSS。
*   **Lambda (FC)**: 负责动态 HTML 渲染。
*   **CloudFront (CDN)**: 
    *   **动静分离**：通过路径映射 (`/static` -> S3, `/*` -> Lambda) 实现高效率分流。
    *   **被动缓存 (Pull Model)**：边缘节点按需缓存静态资源，极大降低主站压力。

---

## 4. 关键技术栈

| 组件 | 选型 | 理由 |
| :--- | :--- | :--- |
| **UI 库** | React 19 | 利用 `renderToPipeableStream` 实现极致的流式渲染性能。 |
| **数据同步** | TanStack Query v5 | 统一前后端请求模型，通过 `HydrationBoundary` 实现数据无缝脱水/水合。 |
| **资源追踪** | @loadable/server | 精准分析异步组件，解决首屏 CSS/JS 注入问题。 |
| **构建工具** | Webpack 5 | 多编译器 (Multi-compiler) 模式，确保双端打包一致性。 |
| **安全加固** | koa-helmet | 预置生产级安全头，降低 SSR 被攻击风险。 |

---

## 5. 架构演进建议

由于目前业务逻辑与 SSR 框架逻辑耦合度较高，未来可考虑：
1. **抽离核心**：将 SSR 渲染中间件封装为独立 npm 包。
2. **Monorepo 化**：通过 `pnpm-workspace` 隔离框架层与业务层。
